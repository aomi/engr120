#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    extRight,       sensorReflection)
#pragma config(Sensor, in2,    intLeft,        sensorReflection)
#pragma config(Sensor, in3,    intRight,       sensorReflection)
#pragma config(Sensor, dgtl2,  bumpRearRight,  sensorTouch)
#pragma config(Sensor, dgtl3,  ultrasonicInput, sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  redLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl6,  orangeLED,      sensorDigitalOut)
#pragma config(Sensor, dgtl9,  limitFrontRight, sensorTouch)
#pragma config(Sensor, dgtl11, limitFrontLeft, sensorTouch)
#pragma config(Sensor, dgtl12, bumpRearLeft,   sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           connector,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef enum {
	SCAN = 0,
	LIGHT_OFF,
	LIGHT_ON,
	STOP,
} T_State;
const int driveSpeed = 16;
const int light_threshold = 200;

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
bool monitorLight()
{
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[extRight];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);
}

task main()
{
	T_State robot_state = SCAN;
	bool beaconVisible;
	SensorValue[orangeLED] = 0;
	SensorValue[redLED] = 0;

	while( true ) {
		// Update sensor values (must be called at least 20 times a second for proper performance).
		beaconVisible = monitorLight();
		switch( robot_state ) {
		case SCAN:
			if(beaconVisible){
				robot_state = STOP;
			} else {
				motor[leftDrive] = driveSpeed;
				motor[rightDrive] = -driveSpeed;
			}
			break;
		case STOP:
			motor[leftDrive] = 0;
			motor[rightDrive] = 0;
			robot_state = LIGHT_ON;
			break;
		case LIGHT_OFF:
			SensorValue[orangeLED] = 0;
			if ( beaconVisible ) {
				robot_state = LIGHT_ON;
				} else {
				robot_state = LIGHT_OFF;
			}
			break;
		case LIGHT_ON:
			SensorValue[orangeLED] = 1;
			robot_state = LIGHT_ON;
			break;
		default:
			// This should never happen.
			robot_state = LIGHT_OFF;

		} // switch( robot_state)

	}  // while(true)

}
