#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    extRight,       sensorReflection)
#pragma config(Sensor, in2,    intLeft,        sensorReflection)
#pragma config(Sensor, in3,    intRight,       sensorReflection)
#pragma config(Sensor, dgtl2,  bumpRearRight,  sensorTouch)
#pragma config(Sensor, dgtl3,  ultrasonicInput, sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  redLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl6,  greenLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl9,  limitFrontRight, sensorTouch)
#pragma config(Sensor, dgtl11, limitFrontLeft, sensorTouch)
#pragma config(Sensor, dgtl12, bumpRearLeft,   sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           connector,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int light_threshold = 160;
const int beacon_height = 8;
const int floor_height = 18;
typedef enum {
	CHECK = 0,
	LIGHT_ON,
	LIGHT_OFF
} T_State;

bool monitorLightIntLeft(){
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[intLeft];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {
		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;
		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}
	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		} else {
		returnValue = false;
	}
	return(returnValue);
}

bool monitorLightIntRight(){
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[intRight];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T2] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T2);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);
}

bool monitorSonar(){
	return SensorValue[ultrasonicInput] < 11;
}

task main(){
	T_State robot_state = CHECK;
	bool beaconVisibleLeft;
	bool beaconVisibleRight;
	SensorValue[greenLED] = 0;
	SensorValue[redLED] = 1;
	while(true){
		beaconVisibleLeft = monitorLightIntLeft();
		beaconVisibleRight = monitorLightIntRight();

		switch(robot_state){
			case CHECK:
				if(beaconVisibleLeft && beaconVisibleRight && monitorSonar()){
					robot_state = LIGHT_ON;
				} else {
					robot_state = CHECK;
				}
				break;
			case LIGHT_ON:
				SensorValue[greenLED] = 1;
				SensorValue[redLED] = 0;
				if(!(monitorLightIntRight() && monitorLightIntLeft() && monitorSonar())){
					robot_state = LIGHT_OFF;
				}
				break;
			case LIGHT_OFF:
				SensorValue[redLED] = 1;
				SensorValue[greenLED] = 0;
				robot_state = CHECK;
				break;
			default:
				robot_state = CHECK;
				break;
		}
	}
}
