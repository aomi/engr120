#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    extRight,       sensorReflection)
#pragma config(Sensor, in2,    intLeft,        sensorReflection)
#pragma config(Sensor, in3,    intRight,       sensorReflection)
#pragma config(Sensor, dgtl2,  bumpRearRight,  sensorTouch)
#pragma config(Sensor, dgtl3,  ultrasonicInput, sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  redLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl6,  orangeLED,      sensorDigitalOut)
#pragma config(Sensor, dgtl9,  limitFrontRight, sensorTouch)
#pragma config(Sensor, dgtl11, limitFrontLeft, sensorTouch)
#pragma config(Sensor, dgtl12, bumpRearLeft,   sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           connector,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const static int driveSpeed = 50;

typedef enum {
	IDLE = 0,
	MOVE,
	STOP,
	LIGHT_OFF,
	LIGHT_ON
} T_State;

bool collision(){
	return (SensorValue[bumpRearLeft]) || (SensorValue[bumpRearRight]) || (SensorValue[limitFrontLeft]) || (SensorValue[limitFrontRight]);
}

task main(){
	T_State robot_state = MOVE;
	while(true){
		switch(robot_state){
		case MOVE:
			if(collision()){
				robot_state = STOP;
			} else {
				motor[leftDrive] = driveSpeed;
				motor[rightDrive] = driveSpeed;
			}
			break;
		case STOP:
			motor[leftDrive] = 0;
			motor[rightDrive] = 0;
			robot_state = LIGHT_ON;
			break;
		case LIGHT_ON:
			SensorValue[redLED] = 1;
			break;
		default:
			robot_state = STOP;
			break;
		}
	}
}
