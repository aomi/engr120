#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    extLeft,        sensorReflection)
#pragma config(Sensor, in2,    intLeft,        sensorReflection)
#pragma config(Sensor, in3,    intRight,       sensorReflection)
#pragma config(Sensor, in4,    extRight,       sensorReflection)
#pragma config(Sensor, dgtl2,  bumpRearRight,  sensorTouch)
#pragma config(Sensor, dgtl3,  ultrasonicInput, sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  redLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl6,  greenLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl9,  limitFrontRight, sensorTouch)
#pragma config(Sensor, dgtl11, limitFrontLeft, sensorTouch)
#pragma config(Sensor, dgtl12, bumpRearLeft,   sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           connector,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// -------------------- Constants -------------------- //
// Speeds
const int releaseTime = 7000;//ms
const int maxDriveSpeed = 40;
const int dockSpeed = 20;

// Infrared Threshold Values
const int internalLightThreshold = 130;

// Ultrasonic Measured Distances
const int minDistance = 5;
const int extLightThresholdTrim = 30;

// Max Scanning
const int scanMaxNorm = 700;
const int ultrasonicCounterThreshold = 70;

// -------------------- Structs and Enums -------------------- //
typedef struct {
	int i_left;
	int i_right;
	int e_left;
	int e_right;
} t_infrared;

enum T_State {
	STARTUP,
    INIT_SEARCH,
    SEARCH,
    ALLIGN,
    DRIVE,
    RELEASE,
    FINISH,
    DOCK
};

enum T_State_Found_Status {
    UNKNOWN,
    LEFT,
    RIGHT
};

// -------------------- Global Variables -------------------- //
t_infrared Infrared;
// Active Motor Drive Speeds
int leftDriveSpeed = 0;
int rightDriveSpeed = 0;
int connectorRunSpeed = 0;
int maxTurnSpeed = 27;
int maxTurnAllignSpeed = 23;

// Beacon Search Booleans
bool finalSearch;
bool midFound = false;
bool ultrasonicFound = false;

// Adjustment
const int trim = 0;

//Measurement Comparator
int extLightThreshold = 150;
int ultrasonicCounter = 0;
int scanMax = 1400;

//Infrared Values
int leftLimit;
int rightLimit;
int diffLevelExt;
int diffLevelInt;

// -------------------- Functions -------------------- //

/*

    Function: monitorLightExternal
    Updates the external infrared sensor values.
    Parameters: n/a
    Return: n/a

*/
void monitorLightExternal(){
	static int minLevelLeft = 4096;
	static int maxLevelLeft = 0;
	static int diffLevelLeft = 0;

	static int minLevelRight = 4096;
	static int maxLevelRight = 0;
	static int diffLevelRight = 0;

	int lightLevelLeft = SensorValue[extLeft];
	int lightLevelRight = SensorValue[extRight];
	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {
		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelLeft = maxLevelLeft - minLevelLeft;
		diffLevelRight = maxLevelRight - minLevelRight;

		// Reset calculation for next 100 msecs.;
		maxLevelLeft = 0;
		minLevelLeft = 4096;
		maxLevelRight = 0;
		minLevelRight = 4096;
		clearTimer(T1);
	} else {
		// Check for new minimum/maximum light levels.
		if (lightLevelLeft < minLevelLeft ) {
			minLevelLeft = lightLevelLeft;
		} else if ( lightLevelLeft > maxLevelLeft ) {
			maxLevelLeft = lightLevelLeft;
		}
		if ( lightLevelRight < minLevelRight ) {
			minLevelRight = lightLevelRight;
		} else if ( lightLevelRight > maxLevelRight ) {
			maxLevelRight = lightLevelRight;
		}
	}
	Infrared.e_left = diffLevelLeft;
	Infrared.e_right = diffLevelRight;
}


/*

    Function: monitorLightInternal
    Updates the internal infrared sensor values.
    Parameters: n/a
    Return: n/a

*/
void monitorLightInternal(){
	static int minLevelLeft = 4096;
	static int maxLevelLeft = 0;
	static int diffLevelLeft = 0;

	static int minLevelRight = 4096;
	static int maxLevelRight = 0;
	static int diffLevelRight = 0;

	int lightLevelLeft = SensorValue[intLeft];
	int lightLevelRight = SensorValue[intRight];
	// Check if 100 msecs have elapsed.
	if ( time1[T2] > 100 )  {
		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelLeft = maxLevelLeft - minLevelLeft;
		diffLevelRight = maxLevelRight - minLevelRight;

		// Reset calculation for next 100 msecs.;
		maxLevelLeft = 0;
		minLevelLeft = 4096;
		maxLevelRight = 0;
		minLevelRight = 4096;
		clearTimer(T2);
	} else {
		// Check for new minimum/maximum light levels.
		if (lightLevelLeft < minLevelLeft ) {
			minLevelLeft = lightLevelLeft;
		} else if ( lightLevelLeft > maxLevelLeft ) {
			maxLevelLeft = lightLevelLeft;
		}
		if ( lightLevelRight < minLevelRight ) {
			minLevelRight = lightLevelRight;
		} else if ( lightLevelRight > maxLevelRight ) {
			maxLevelRight = lightLevelRight;
		}
	}
	Infrared.i_left = diffLevelLeft;
	Infrared.i_right = diffLevelRight;
}


/*

    Function: executeFlipDrive
    Inverts the drive speed of the motors.
    Parameters:
        modifier - adjusts speed based on float value.
    Return: n/a

*/
void executeFlipDrive(int modifier = 1){
    leftDriveSpeed *= -modifier;
    rightDriveSpeed *= -modifier;
}


/*

    Function: executeSetDrive
    Set the drive speed of left and drive drive and can also reset rightDrive encoder.
    Parameters:
        left - leftDriveSpeed
        right - rightDriveSpeed
        reset - if set true, will reset the right motor encoder.
    Return: n/a

*/
void executeSetDrive(int left, int right, bool reset = false){
    leftDriveSpeed = left;
    rightDriveSpeed = right;
    if(reset) resetMotorEncoder(rightDrive);
}


/*

    Function: executeSetLight
    Set the LEDs on or off depending on parameters.
    Parameters:
        red - on/off
        green - on/off
    Return: n/a

*/
void executeSetLights(int red = 0, int green = 0){
    SensorValue[redLED] = red;
    SensorValue[greenLED] = green;
}


/*

    Function: systemErrorFlash
    Freezes the program and flashes the LEDs.
    Parameters: n/a
    Return: n/a

*/
void systemErrorFlash(){
	motor[rightDrive] = 0;
	motor[leftDrive] = 0;
    motor[connector] = 0;
    while(true){
        SensorValue[redLED] = 1;
        wait1Msec(500);
        SensorValue[redLED] = 0;
        SensorValue[greenLED] = 1;
        wait1Msec(500);
        SensorValue[greenLED] = 0;
    }
}


/*

    Function: systemPause
    Hangs the program when executed and releases if button is pressed.
    Used for debuging purposes
    Parameters: n/a
    Return: n/a

*/
void systemPause(){
	while(true){
		motor[leftDrive] = 0;
		motor[rightDrive] = 0;
		if(SensorValue[bumpRearLeft]){
            SensorValue[redLED] = 1;
            SensorValue[greenLED] = 1;
            wait1Msec(500);
            SensorValue[redLED] = 0;
            SensorValue[greenLED] = 0;
			break;
		}
	}
}

// -------------------- Main Program -------------------- //
task main(){

		T_State robot_state = STARTUP;
    T_State_Found_Status find_state = UNKNOWN;
    executeSetLights();

    while(true){
        // Update Motors
        motor[leftDrive] = leftDriveSpeed;
        motor[rightDrive] = rightDriveSpeed;
        motor[connector] = connectorRunSpeed;

        // Beginning Finite State Machine
        switch(robot_state){

        		case STARTUP:
                // STARTUP: Prepare the robot for execution with loading.

                if(SensorValue[bumpRearLeft]){ // Load the connector.
                    connectorRunSpeed = 50;
              	} else if(SensorValue[bumpRearRight]){
              		connectorRunSpeed = -50;
                } else if(SensorValue[limitFrontLeft]){ // Start the program.
                    connectorRunSpeed = 0;
                    robot_state = INIT_SEARCH;
                } else { // Stop connector.
                    connectorRunSpeed = 0;
                }
                break;

            case INIT_SEARCH:
                // INIT_SEARCH: Prepare the SEARCH function.
                midFound = false;
                // Reset motor encoder and assign motors speed for clockwise rotation.
                executeSetDrive(maxTurnSpeed, -maxTurnSpeed, true);
                // Turn off LEDs
                executeSetLights();
                // Change state to SEARCh and set find_state to UNKNOWN.
                robot_state = SEARCH;
                find_state = UNKNOWN;
                break;

            case SEARCH:
                // SEARCH: Find the beacon with the infrared sensors.

                // Update the sensor values.
                monitorLightExternal();
                // Check if infrared sensors find the beacon.
            	bool leftFound = (Infrared.e_left > extLightThreshold) && (find_state != LEFT);
               	bool rightFound = (Infrared.e_right > extLightThreshold) && (find_state != RIGHT);

                //The following two conditionals check to see if whether the right or left infrared sensor value is above the threshold.
               	//Once one of the sensors recieves a signal, the robot will mark the position and search until the second sensors recieves a signal.
               	//Both positions are recorded as well as which sensor identified the beacon first for use in the ALIGN state.

               	if(leftFound){
                	SensorValue[redLED] = 1;
                    if(find_state == UNKNOWN){
                        leftLimit = getMotorEncoder(rightDrive);
                        // Invert rotation if robot is going clockwise.
                        if(leftDriveSpeed > 0) executeFlipDrive();
                         // Set find_state to indicate which infrared sensor triggered first.
                        find_state = LEFT;
                    } else if(find_state == RIGHT){
                        // Save Left Side Limit.
                        leftLimit = getMotorEncoder(rightDrive);
                        // Store the difference level to determine distance away from beacon.
                        diffLevelExt = Infrared.e_left;
                        diffLevelInt = Infrared.i_left;
                        // Stop motors and change the robot_state to ALLIGN.
                        executeSetDrive(0,0, true);
                        robot_state = ALLIGN;
                    }
                } else if(rightFound){
                	SensorValue[greenLED] = 1;
                    if(find_state == UNKNOWN){
                        rightLimit = getMotorEncoder(rightDrive);
                        // Invert rotation if robot is going counterclockwise.
                        if(leftDriveSpeed < 0) executeFlipDrive();
                        // Set find_state to indicate which infrared sensor triggered first.
                        find_state = RIGHT;
                    } else if(find_state == LEFT){
                        // Save Right Side Limit.
                        rightLimit = getMotorEncoder(rightDrive);
                        // Store the difference level to determine distance away from beacon.
                        diffLevelExt = Infrared.e_right;
                        diffLevelInt = Infrared.i_right;
                        // Stop motors and change the robot_state to ALLIGN.
                        executeSetDrive(0,0, true);
                       // systemPause();

                        robot_state = ALLIGN;
                    }
                } else if((getMotorEncoder(rightDrive) < -scanMax) && (leftDriveSpeed > 0)){
                    // Invert rotation if robot is out of rotation bounds and going clockwise.
                    extLightThreshold += -extLightThresholdTrim;
                	executeFlipDrive();
                } else if((getMotorEncoder(rightDrive) > scanMax) && (leftDriveSpeed < 0)){
                    // Invert rotation if robot is out of rotation bounds and going counterclockwise.
                    extLightThreshold += -extLightThresholdTrim;
                	executeFlipDrive();
                }
                break;

            case ALLIGN:
                //ALLIGN: Take the limit values found within the SEARCH state and try to centre allign.

                // Lowers the scan range after the initial search a the robot should be in the general direction of the beacon
                scanMax = scanMaxNorm;

                //The following conditionals move the robot to the centre of the two positions where the infrared signals triggered
                //Depending on which sensor triggered first, the robot will turn the correct direction to account for this

                int delta = (int)(fabs(leftLimit - rightLimit) / 2);
                if(find_state == RIGHT){ // Right sensor triggered first.
                    // Currently at left limit.
                    // Set motors to go counterclockwise.
                    executeSetDrive(-maxTurnAllignSpeed, maxTurnAllignSpeed);
                    // Calculate the midway point to allign robot.
                    if(getMotorEncoder(rightDrive) > (delta + trim)){ // Robot has reached midway point.
                        midFound = true;
                        // Robot is alligned so proceed to DRIVE state.
                        executeSetDrive(0,0, true);
                        if(finalSearch){
                            resetMotorEncoder(rightDrive);
                            robot_state = DOCK;
                        } else {
                            robot_state = DRIVE;
                        }

                  	}
                } else if(find_state == LEFT){ // Left sensor triggered first.
                    // Currently at right limit
                    // Set motors to go clockwise.
            		executeSetDrive(maxTurnAllignSpeed, -maxTurnAllignSpeed);
                    // Calculate the midway point to allign robot.
                    if(getMotorEncoder(rightDrive) < (delta - trim)){ // Robot has reached midway point.
                        midFound = true;
                        // Robot is alligned so proceed to DRIVE state.
                        executeSetDrive(0,0);
                        resetMotorEncoder(rightDrive);
                    	if(finalSearch){
                            resetMotorEncoder(rightDriveSpeed);
                            robot_state = DOCK;
                        } else {
                            robot_state = DRIVE;
                        }
                    }
                }
                break;

            case DRIVE:
                // DRIVE: Progress forwards towards the beacon.
                monitorLightInternal();
                executeSetDrive(maxDriveSpeed,maxDriveSpeed);
                // Keep going forward until ultrasonic is out of range or it goes 2000 ticks.
                // Once either conditional is met, return to INIT_SEARCH.
           		  if((getMotorEncoder(rightDrive) > 2000) || (SensorValue[ultrasonicInput] == -1)){
            	    robot_state = INIT_SEARCH;
              	}

                // The following determines if the ultrasonic value is under  certain threshold.
              	// If the value remains under the threshold for a specified amount of time, finalsearch is set to true before re-entering INIT_SEARCH state.
              	// Also checks if the internal IR sensors have been triggered.
              	// If the value increases however, reset the counter.
              	if(SensorValue[ultrasonicInput] < 33) ultrasonicFound = true;

                if(ultrasonicFound){
                    if (SensorValue[ultrasonicInput] < 33){
                        ultrasonicCounter++;
                        if (ultrasonicCounter > ultrasonicCounterThreshold){
                        		if((Infrared.i_right > internalLightThreshold) && (Infrared.i_left > internalLightThreshold)){
                                finalSearch = true;
                                // Go for a slower search because its the final search.
                                maxTurnSpeed = 17;
                                maxTurnAllignSpeed = 17;
                                robot_state = INIT_SEARCH;
                            }
                        }
                    } else {
                        ultrasonicCounter = 0;
                        ultrasonicFound = false;
                    }
                }
                break;

            case DOCK:
                // DOCK: Drive towards beacon and stop.

                executeSetDrive(dockSpeed, dockSpeed);
                // Infront of beacon so deploy the connector.
                if(SensorValue[ultrasonicInput] < minDistance){
                    clearTimer(T3);
                    executeSetDrive(0,0);
                    robot_state = RELEASE;
                }
                break;

            case RELEASE:
                // RELEASE: Release the connector and mount to beacon.

                if(time1[T3] > releaseTime){
                    resetMotorEncoder(rightDrive);
                    connectorRunSpeed = 0;
                    robot_state = FINISH;
                } else {
                    // Release the connector.
                    connectorRunSpeed = 127;
                }
                break;

            case FINISH:
                // FINISH: Back up from the beacon.
                executeSetDrive(-70, -70);
                if(getMotorEncoder(rightDrive) < -1300){
                    motor[rightDrive] = 0;
                    motor[leftDrive] = 0;
                    systemErrorFlash();
                }
                break;

            default:
                // This should never happen.
                systemErrorFlash();
                break;

        }
	}
}
