#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl11, button1,        sensorTouch)
#pragma config(Sensor, dgtl12, button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define EXERCISE_NUMBER 	3 //WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input

//FSM states
typedef enum {
	STOPPED,
	FORWARDS,
	BACKWARDS
} T_motor_state ;

/* monitorInput()
*
*  Used to flag button inputs
*       - Note that this function only sets button1_pushed and button2_pushed flags to true.
*         Your code should clear these flags by setting the appropriate variable to false after
*         the appropriate action has been taken.
*
*  Tips on use:
*       - The monitorInput function should be called periodically.
*				  - The function can only set the flags when it is called.
*       - Good practice is to continously call monitorInput and then check what flags have been set.
*         Take action corresponding to flag settings and then set the flags back to false to prevent
*         unwanted action repetitons.
*  Example: Code will execute action 1 once when button 1 is pushed.
*    while(1) {
*      monitorInput();
*      if ( button1_pushed ) {
*        action1();
*        button1_pushed = false;
*      }
*    }
*
*    The button1_pushed = false; line is required to stop code from endlessly
*    repeating action 1 after button is pushed.
*    The action will be repeated if the button is pushed again.
*/
void monitorInput()
{
	if(SensorValue(button1) && !button1_pushed)
	{
		button1_pushed = true;
	}

	if(SensorValue(button2) & !button2_pushed)
	{
		button2_pushed = true;
	}
}

void exercise_1()
{

	while(true)
	{
		monitorInput();
		if( button1_pushed ) {
			motor[motor1] = 50;
			button1_pushed = false;
			} else if(button2_pushed){
			motor[motor1] = 0;
			button2_pushed = false;
		} // end if
	}//end while
}

void exercise_2()
{
	while(true)
	{
		monitorInput();
		resetMotorEncoder(motor1);
		if(button1_pushed)
		{
			while(getMotorEncoder(motor1) <= 627){
				motor[motor1] = 30;
			}
			motor[motor1] = 0;
			button1_pushed = false;
		} // end if
	}// end while

} // end exercise_2

void exercise_3()
{
	//set the initial state to 'STOPPED'
	T_motor_state system_state = STOPPED;
	while(true)
	{
		monitorInput();
		switch (system_state){
		case STOPPED:
			//stops motor and resets enconder
			motor[motor1] = 0;
			resetMotorEncoder(motor1);

			if(button1_pushed){
				system_state = FORWARDS;
			} else if(button2_pushed){
				system_state = BACKWARDS;
			}
			break;
		case FORWARDS:
			button1_pushed = false;
			motor[motor1] = 50;

			if(getMotorEncoder(motor1) > 3000){
				system_state = STOPPED;
			}
			break;
		case BACKWARDS:
			button2_pushed = false;
			motor[motor1] = -50;

			if(getMotorEncoder(motor1) < -3000){
				system_state = STOPPED;
			}
			break;
		}
	}//end while
}//end exercse_3


task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
	{
	case 1:
		exercise_1();
		break;
	case 2:
		exercise_2();
		break;
	case 3:
		exercise_3();
		break;
	default: //should never get here.
	} // end switch

}// end main
